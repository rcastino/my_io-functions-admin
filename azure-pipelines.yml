# Azure DevOps pipeline to build, check source codes, run tests, and deploy.
#
# This pipeline has been implemented to be run on hosted agent pools based both
# on 'windows' and 'ubuntu' virtual machine images and using the scripts defined
# in the package.json file. Since we are deploying on Azure functions on Windows
# runtime, the pipeline is currently configured to use a Windows hosted image.
#
# The following variables needs to be defined in the pipeline before running it:
# - AZURE_SUBSCRIPTION
# - RESOURCE_GROUP_NAME
# - APP_NAME

# - AZURE_SP_TENANT="<tenantid>"
# - AZURE_SP="<service principal id>"
# - AZURE_SP_PASSWORD="<service principal password>"
# - AZURE_SUBSCRIPTION_ID="<subscription id>"
# - PRODUCTION_RESOURCE_GROUP_NAME="<production resource group>"
# - STAGING_RESOURCE_GROUP_NAME="<staging resource group>"
# - FUNCTION_APP_NAME="<function app name>"

variables:
  YARN_CACHE_FOLDER: $(Pipeline.Workspace)/.yarn

# This pipeline is triggered to run whenever a push is made to 
# any branch (not only 'master') or the 'latest' tag is pushed
trigger:
  branches:
    include:
      - '*'
      - refs/tags/latest

#pr:
#  branches:
#    include:
#    - 'master1'

pool:
  vmImage: 'windows-2019'

stages:
  # A) Install modules and build
  - stage: Build_check
    dependsOn: []
    jobs:
      - job: compile
        steps:
        - task: NodeTool@0
          inputs:
            versionSpec: '10.14.1'
          displayName: 'Install Node.js'
        
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache Yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - bash: |
            yarn build
          displayName: 'Build'

      - job: lint
        dependsOn: ['compile']
        steps:
        - checkout: none

        - script: |
            yarn lint
          displayName: 'Lint'


  # B) Checker and validator tools for static code analysis
  - stage: Source_check
    dependsOn: ['Build_check']
    jobs:
      # B1) TODO Analyze source code to find errors
      - job: lint
        steps:
        - task: Cache@2
          condition: false
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache Yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - script: |
            yarn lint
          displayName: 'Lint'

      # B2) Validate API definition 
      - job: lint_api
        condition: false
        steps:
        - script: |
            npx oval validate -p openapi/index.yaml
          displayName: 'Validate OpenAPI'

      # B3) Check source code with danger (only when there is a PR)
      - job: danger
        condition: variables['DANGER_GITHUB_API_TOKEN']
        steps:
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache Yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - bash: |
            yarn danger ci
          displayName: 'Danger CI'


  # C) Run unit tests
  - stage: Tests_check
    dependsOn: []
    condition: false
    jobs:
      - job: unit_tests
        steps:
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache Yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - script: |
            yarn test:coverage
          displayName: 'Unit tests exec'

        - bash: |
            bash <(curl -s https://codecov.io/bash)
          displayName: 'Code coverage'

  # D) TODO Deploy to a slot 
  - stage: Deploy_staging_slot
    dependsOn: []
    condition: false
    jobs:
      - job: deploy
        steps:
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache Yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - bash: |
            yarn build
          displayName: 'Build'

        - task: AzureFunctionApp@1
          inputs:
            azureSubscription: '$(AZURE_SUBSCRIPTION)'
            appType: 'functionApp'
            appName: '$(APP_NAME)'
            deployToSlotOrASE: true
            resourceGroupName: '$(RESOURCE_GROUP_NAME)'
            slotName: 'staging'
            package: '$(System.DefaultWorkingDirectory)/'
            deploymentMethod: 'auto'

        - task: AzureAppServiceManage@0
          inputs:
            azureSubscription: '$(AZURE_SUBSCRIPTION)'
            WebAppName: '$(APP_NAME)'
            ResourceGroupName: '$(RESOURCE_GROUP_NAME)'
            SourceSlot: staging
            SwapWithProduction: true


  # D1) Deploy to STAGING only if there is a push on 'master' branch
  - stage: Deploy_staging
    dependsOn: []
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    jobs:
      - job: prepare_deploy
        steps:
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache Yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - bash: |
            yarn build
          displayName: 'Build'

      - job: deploy
        dependsOn: [prepare_deploy]
        steps:
          - task: AzureFunctionApp@1
            inputs:
              azureSubscription: '$(AZURE_SUBSCRIPTION)'
              appType: 'functionApp'
              appName: '$(APP_NAME)'
              resourceGroupName: '$(RESOURCE_GROUP_NAME)'
              package: '$(System.DefaultWorkingDirectory)/'
              deploymentMethod: 'auto'

  # D2) Deploy to PRODUCTION only if the 'latest' tag is pushed
  - stage: Deploy_prod
    dependsOn: []
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/tags/latest'))
    jobs:
      - job: prepare_deploy
        steps:
        - bash: |            
            if [[ -z "${PRODUCTION_RESOURCE_GROUP_NAME}" ]]
            then
              echo "[error] Set up environment variables first if you want to start a new deploy:"
              echo "[error] variable PRODUCTION_RESOURCE_GROUP_NAME is missing"
              exit 1
            fi
          displayName: 'Check variables'

        - checkout: self
        
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache Yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - bash: |
            yarn build
          displayName: 'Build'

      - job: deploy
        dependsOn: [prepare_deploy]
        steps:
          - task: AzureFunctionApp@1
            inputs:
              azureSubscription: '$(AZURE_SUBSCRIPTION)'
              appType: 'functionApp'
              appName: '$(APP_NAME)'
              resourceGroupName: '$(PRODUCTION_RESOURCE_GROUP_NAME)'
              package: '$(System.DefaultWorkingDirectory)/'
              deploymentMethod: 'auto'
