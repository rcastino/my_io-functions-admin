# Azure DevOps pipeline to build, check source codes, run tests, and deploy.
#
# This pipeline has been implemented to be run on hosted agent pools based both
# on 'windows' and 'ubuntu' virtual machine images and using the scripts defined
# in the package.json file. Since we are deploying on Azure functions on Windows
# runtime, the pipeline is currently configured to use a Windows hosted image.
#
# The following variables needs to be defined before running the pipeline:
# - STAGING_AZURE_SUBSCRIPTION
# - STAGING_RESOURCE_GROUP_NAME
# - STAGING_FUNCTION_APP_NAME
#
# - PRODUCTION_AZURE_SUBSCRIPTION
# - PRODUCTION_RESOURCE_GROUP_NAME
# - PRODUCTION_FUNCTION_APP_NAME

# - AZURE_SP_TENANT="<tenantid>" 
# - AZURE_SP="<service principal id>"
# - AZURE_SP_PASSWORD="<service principal password>"
# - AZURE_SUBSCRIPTION_ID="<subscription id>"
# - PRODUCTION_RESOURCE_GROUP_NAME="<production resource group>"
# - STAGING_RESOURCE_GROUP_NAME="<staging resource group>"
# - FUNCTION_APP_NAME="<function app name>"

variables:
  YARN_CACHE_FOLDER: $(Pipeline.Workspace)/.yarn
  #DO_DEPLOY: True
  DEPLOY_TO_SLOT: False

# This pipeline is triggered to run whenever a push is made to 
# any branch (not only 'master') or the 'latest' tag is pushed
trigger:
  branches:
    include:
      - '*'
      - refs/tags/latest

#pr:
#  branches:
#    include:
#    - 'master1'

pool:
  vmImage: 'windows-2019'

stages:
  # A) Build and code validation
  - stage: Build
    dependsOn: []
    jobs:
      # A1) Checkout, install module and compile
      - job: compile
        steps:
        - task: NodeTool@0
          inputs:
            versionSpec: '10.14.1'
          displayName: 'Install node.js'

        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - bash: |
            yarn build
          displayName: 'Build'

      # A2) Analyze source code to find errors with lint
      - job: lint
        steps:        
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - script: |
            yarn lint
          displayName: 'Lint'

      # A3) Validate API definition
      - job: lint_api
        steps:
        - script: |
            npx oval validate -p openapi/index.yaml
          displayName: 'Validate openAPI'

      # A4) Check source code with danger (only when there is a PR)
      - job: danger
        condition: and(succeeded(),
            and(
              variables['DANGER_GITHUB_API_TOKEN'], 
              ne(variables['Build.SourceBranch'], 'refs/heads/master')
            )
          )
        steps:
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - bash: |
            yarn danger ci
          displayName: 'Danger CI'


  # B) Run unit tests
  - stage: Test
    dependsOn: []
    jobs:
      - job: unit_tests
        steps:
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - script: |
            yarn test:coverage
          displayName: 'Unit tests exec'

        - bash: |
            bash <(curl -s https://codecov.io/bash)
          displayName: 'Code coverage'


  # C) Deploy to STAGING only if there is a push on 'master' branch.
  # Other conditions based on variables settings:
  # - $DO_DEPLOY != True (or undefined): skip deployment
  # - c1) $DEPLOY_TO_SLOT != True (or undefined): deploy to stage environment
  # - c2) $DEPLOY_TO_SLOT == True: deploy to staging slot in production environment
  - stage: Deploy_staging
    condition: and(succeeded(),
        and(
          eq(variables['DO_DEPLOY'], True), 
          eq(variables['Build.SourceBranch'], 'refs/heads/master')
        )
      )
    dependsOn: []
    #- Build
    #- Test
    jobs:
      - job: deploy_to_staging
        steps:
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - bash: |
            yarn build
          displayName: 'Build'

        # c1) First option: standard deployment (without slot)
        - task: AzureFunctionApp@1
          condition: and(succeeded(), ne(variables['DEPLOY_TO_SLOT'], True))
          inputs:
            azureSubscription: '$(STAGING_AZURE_SUBSCRIPTION)'
            resourceGroupName: '$(STAGING_RESOURCE_GROUP_NAME)'
            appType: 'functionApp'
            appName: '$(STAGING_FUNCTION_APP_NAME)'
            package: '$(System.DefaultWorkingDirectory)/'
            deploymentMethod: 'auto'
          displayName: Deploy to staging env

        # c2) Alternative option: deployment to 'staging' slot in production env
        - task: AzureFunctionApp@1
          condition: and(succeeded(), eq(variables['DEPLOY_TO_SLOT'], True))
          inputs:
            azureSubscription: '$(PRODUCTION_AZURE_SUBSCRIPTION)'
            resourceGroupName: '$(PRODUCTION_RESOURCE_GROUP_NAME)'
            appType: 'functionApp'
            appName: '$(PRODUCTION_FUNCTION_APP_NAME)'
            package: '$(System.DefaultWorkingDirectory)/'
            deploymentMethod: 'auto'
            deployToSlotOrASE: true
            slotName: 'staging'
          displayName: Deploy to staging slot in prod


  # D) Deploy to PRODUCTION only if the 'latest' tag is pushed
  - stage: Deploy_production
    condition: and(succeeded(),
        and(
          eq(variables['DO_DEPLOY'], true), 
          eq(variables['Build.SourceBranch'], 'refs/tags/latest')
        )
      )
    dependsOn:
    - Build
    - Test
    jobs:
      - job: deploy_to_production
        steps:
        - bash: |            
            if [[ -z "${PRODUCTION_RESOURCE_GROUP_NAME}" ]]
            then
              echo "[error] Set up environment variables first if you want to start a new deploy:"
              echo "[error] variable PRODUCTION_RESOURCE_GROUP_NAME is missing"
              exit 1
            fi
          displayName: 'Check variables'

        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - bash: |
            yarn build
          displayName: 'Build'

        - task: AzureFunctionApp@1
          inputs:
            azureSubscription: '$(PRODUCTION_AZURE_SUBSCRIPTION)'
            appType: 'functionApp'
            appName: '$(PRODUCTION_FUNCTION_APP_NAME)'
            resourceGroupName: '$(PRODUCTION_RESOURCE_GROUP_NAME)'
            package: '$(System.DefaultWorkingDirectory)/'
            deploymentMethod: 'auto'
          displayName: Deploy function app




  # D) TODO Deploy to a slot 
  - stage: Deploy_staging_slot
    dependsOn: []
    condition: false
    jobs:
      - job: deploy
        steps:
        - task: Cache@2
          inputs:
            key: 'yarn | "$(Agent.OS)" | yarn.lock'
            restoreKeys: |
              yarn | "$(Agent.OS)"
              yarn
            path: $(YARN_CACHE_FOLDER)
          displayName: Cache yarn packages

        - script: |
            yarn install --frozen-lockfile --no-progress --non-interactive --network-concurrency 1
          displayName: 'Install node modules'

        - bash: |
            yarn build
          displayName: 'Build'

        - task: AzureFunctionApp@1
          inputs:
            azureSubscription: '$(PRODUCTION_AZURE_SUBSCRIPTION)'
            appType: 'functionApp'
            appName: '$(PRODUCTION_FUNCTION_APP_NAME)'
            deployToSlotOrASE: true
            resourceGroupName: '$(PRODUCTION_RESOURCE_GROUP_NAME)'
            slotName: 'staging'
            package: '$(System.DefaultWorkingDirectory)/'
            deploymentMethod: 'auto'

        - task: AzureAppServiceManage@0
          inputs:
            azureSubscription: '$(PRODUCTION_AZURE_SUBSCRIPTION)'
            WebAppName: '$(PRODUCTION_FUNCTION_APP_NAME)'
            ResourceGroupName: '$(PRODUCTION_RESOURCE_GROUP_NAME)'
            SourceSlot: staging
            SwapWithProduction: true

